;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 32

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 1
db T_BOOL, 0
MAKE_LITERAL_RATIONAL(3,1)
MAKE_LITERAL_RATIONAL(4,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(2,1)
MAKE_LITERAL_PAIR(const_tbl+57, const_tbl+1)
MAKE_LITERAL_PAIR(const_tbl+40, const_tbl+74)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+4
%define SOB_TRUE_ADDRESS const_tbl+2

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl + (0 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl + (1 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl + (2 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl + (3 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl + (4 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl + (5 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl + (6 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl + (7 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl + (8 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl + (9 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl + (10 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl + (11 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl + (12 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl + (13 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl + (14 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl + (15 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl + (16 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl + (17 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl + (18 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl + (19 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl + (20 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl + (21 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl + (22 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl + (23 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl + (24 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl + (25 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl + (26 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl + (27 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl + (28 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl + (29 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl + (30 * 8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl + (31 * 8)], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
push SOB_NIL_ADDRESS
mov rax, const_tbl + 91

push rax

mov rax, const_tbl + 23

push rax

mov rax, const_tbl + 6

push rax

mov rbx, SOB_NIL_ADDRESS			; rbx hold the env which is empty in this situation
MAKE_CLOSURE(rax,rbx, Lcode2)

     jmp Lcont2
Lcode2:
push rbp

     mov rbp, rsp

     mov rbx, qword[rbp+3*8]			; rbx hold the number of argumnents

     mov rcx, 0			; rcx hold the number of arguments that lambda opt has

     cmp rbx, rcx			; if they are equal, there is no need to fix the stack

     je finish_fix_stack2

     mov rdx, 0

     mov rdi, [rbp+((4+rbx-1)*8)]			 ; rdi hold the last parameter

     MAKE_PAIR(rax, rdi, SOB_NIL_ADDRESS)			 ; make pair from the last argument

     push rbx

     dec rbx

     start_pair_loop2:

     cmp rbx, rcx

     je end_pair_loop2
     mov rdi, [rbp+((4+rbx-1)*8)]			; rdi hold the current parameter

     mov rsi, rax			; save the pointer for the current pair 

     MAKE_PAIR(rax, rdi, rsi)			; update the pair

     dec rbx

     inc rdx

     jmp start_pair_loop2

     end_pair_loop2:

     pop rbx

     mov [rbp+((4+rbx-1)*8)], rax

     add rbx, 2

     mov rcx, rbx

     sub rcx, rdx

     start_copy_stack2:

     mov rax, qword[rbp+rcx*8]

     mov [rbp+rbx*8], rax

     dec rbx

     dec rcx

     cmp rcx, 0

     jne start_copy_stack2

     end_copy_stack2:

     pop_loop2:

     cmp rdx, 0
     je end_pop_loop2

     add rsp, 8

     dec rdx

     jmp pop_loop2

     end_pop_loop2:

     mov rbp, rsp
     mov qword[rbp+24], 1

     finish_fix_stack2:
mov rax, qword[rbp+ 8*(4+0)]


     leave

     ret

     Lcont2:

push rax
push 4
mov rax, [fvar_tbl + (31 * 8)]

CLOSURE_ENV rbx, rax

   push rbx

   CLOSURE_CODE rax, rax

   call rax

   mov rdx, [rsp+8]

   add rdx, 3

   cleanloop1:

   cmp rdx, 0

   je end_cleanloop1

   add rsp, 8

   dec rdx

   jmp cleanloop1

   end_cleanloop1:

call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
       pop rbp
       ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
       pop rbp
       ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
       pop rbp
       ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
       pop rbp
       ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
       pop rbp
       ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
       pop rbp
       ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
       pop rbp
       ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
       pop rbp
       ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
       pop rbp
       ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
       pop rbp
       ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
       pop rbp
       ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
       pop rbp
       ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
       pop rbp
       ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
       pop rbp
       ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
       pop rbp
       ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	     CAR rax, rsi
       pop rbp
       ret

cdr:
      push rbp
      mov rbp, rsp 
      mov rsi, PVAR(0)
      CDR rax, rsi
      pop rbp
      ret

set_car:
      push rbp
      mov rbp, rsp 
      mov rsi, PVAR(0)
      mov rdi, PVAR(1)
      mov[rsi+TYPE_SIZE], rdi
      pop rbp
      ret

set_cdr:
      push rbp
      mov rbp, rsp 
      mov rsi, PVAR(0)
      mov rdi, PVAR(1)
      mov[rsi+TYPE_SIZE+WORD_SIZE], rdi
      pop rbp
      ret

cons:
      push rbp
      mov rbp, rsp 
      mov rsi, PVAR(0)
      mov rdi, PVAR(1)
      MAKE_PAIR(rax, rsi, rdi)
      pop rbp
      ret

apply:
      push rbp
      mov rbp, rsp
      mov rcx, [rbp + 24]               ; argument count
      shl rcx, 3                        ; times 8
      add rcx, rbp      
      add rcx, 24      
      mov rsi, [rcx]                    ; rsi now points to the list      
      xor rcx, rcx                      ; Clear rcx for counting
      push SOB_NIL_ADDRESS              ; Push magic
      .push_args_loop:
        CAR rax, rsi  
        push rax                        ; push list argument
        inc rcx                         ; increase the counter
        CDR rsi, rsi   
        cmp rsi, SOB_NIL_ADDRESS
        jne .push_args_loop
      mov rax, rsp
      mov rbx, rbp
      sub rbx, 16                     ; rbx now points at the first arg of the list
      cmp rax, rbx
      je .check_for_extra_args
      mov rsi, [rbx]                  ; arg at the top
      mov rdx, [rax]                  ; switch cells  
      mov [rbx], rdx
      mov [rax], rsi
      add rax, 8
      sub rbx, 8
      .check_for_extra_args:
        mov rax, [rbp + 24]             ; argument count
        sub rax, 2                      ; ignore list and proc
        jz .finish_apply
        mov rbx, rbp
        add rbx, 40
      .push_extra_args:
        push qword [rbx]    
        add rbx, 8
        dec rax
        jnz .push_extra_args
      .switch_extra_args:
        mov rax, rsp
        mov rbx, rcx                    ; length of the list
        shl rbx, 3                      ; times 8
        sub rbx, rbp                    ; rbx <- (length * 8) -rbp
        neg rbx                         ; rbx <- rbp - (length * 8)
        sub rbx, 16                     ; rbx now points at the first arg of the extra args
        cmp rax, rbx                    
        je .finish_apply
        mov rsi, [rbx]                  ; arg at the top
        mov rdx, [rax]                  ; switch cells  
        mov [rbx], rdx
        mov [rax], rsi
        add rax, 8
        sub rbx, 8
      .finish_apply:
        mov rax, [rbp + 24]
        sub rax, 2                      ; ignore list and proc
        add rax, rcx
        push rax
        mov rax, PVAR(0)        ; Closure
        CLOSURE_ENV rbx, rax
        push rbx
        CLOSURE_CODE rax, rax
        call rax
        mov rdx, [rsp + 8]
        add rdx, 3
      .cleanloop:
        cmp rdx, 0
        je .end_cleanloop;
        add rsp, 8
        dec rdx
        jmp .cleanloop
      .end_cleanloop:
        pop rbp
        ret